/*
* amytiss.cpu.cl
*
*  date    : 28.04.2019
*  author  : M. Khaled | Hybrid control systems @ Technical University of Munich, Germany
*  about   : an OpenCL kernel (optimized for CPUs) used to of the tool AMYTISS.
*            AMYTISS is a tool for an abstractuin based synthesis of stochastic systems.
* ***********************************************************************
*  The kernel manager will replace parameters enclosed by "@@" before compiling !
*/

#define CPU_VERSION

/* includes for the growth bound method */
// /home/hcs/Documents/pFaces/examples/pirk/ex_tridiag/hi.cl



/* common utility file */

// code to load the dynamics from the config file. TODO: integrate this back in
/* the dynamics post function without any noise : noise is assumed to be additive */
//void dynamics_element(__global float* dx, __global float* x, __global float* u, float t, int i);
//void dynamics_element(__global float* dx, __global float* x, __global float* u, float t, int i) {
//  dx[i] = x[i];
//}
#include "/home/hcs/Documents/pFaces/examples/pirk/ex_tridiag/dynamics.cl"
#include "/home/hcs/Documents/pFaces/examples/pirk/ex_tridiag/bounds.cl"

//float growth_bound_matrix(int i, int j, __global float* u)
//{
//  float c;
//  if(i==j) c = 1.0; else c = 0.0;
//  return c;
//}
#include "/home/hcs/Documents/pFaces/examples/pirk/ex_tridiag/growth_bound_matrix.cl"


float growth_bound_radius_dynamics( __global float* r, __global float* u, float t, int i)
{
  float dr;
  dr = 0;
  for (int j=0; j < 10; j++) {
    dr += growth_bound_matrix(i,j,u)*r[j];
  }
  dr += u[i]; //this is causing the bug
  return dr;
}


__kernel void gb_initialize_center( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp)
{
  float x_low, x_up, u_low, u_up;
  int i = get_global_id(0);
  x_low = initial_state_lower_bound(i);
  x_up = initial_state_upper_bound(i);
  u_low = input_lower_bound(i);
  u_up = input_upper_bound(i);
  /* for the center dynamics, we want the initial state to be the center of the interval 
   * (hence the name), that is the mean of the upper and lower bound. */
  initial_state[i] = 0.5 * (x_low + x_up);
  final_state[i] = 0;
  k0[i] = 0;
  k1[i] = 0;
  k2[i] = 0;
  k3[i] = 0;
  tmp[i] = 0;
  input[i]=0.5 * (u_up + u_low);

}


#define RK4_NINT 5
#define RK4_H ((0.010000/RK4_NINT))

__kernel void gb_integrate_center( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp)
{

  int i = get_global_id(0);
  float t = 0.000000;
  int nsteps = 100;
  float step_size = 0.010000;
  float dif; 
  final_state[i] = initial_state[i];
  barrier(CLK_GLOBAL_MEM_FENCE);
  for (unsigned int k=0; k < 100; k++) {
      barrier(CLK_GLOBAL_MEM_FENCE);
      dif = final_state[4];
    for (unsigned int w = 0; w < RK4_NINT; w++) {
      barrier(CLK_GLOBAL_MEM_FENCE);
    
      #define dyn_fn dynamics_element
      #include "dynamics_body.cl"
      barrier(CLK_GLOBAL_MEM_FENCE);

    }
    barrier(CLK_GLOBAL_MEM_FENCE);
    //if (i == 4) printf("%f\n",final_state[4]-dif);
  }
  barrier(CLK_GLOBAL_MEM_FENCE);
}
__kernel void gb_initialize_radius( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp)
{
  float x_low, x_up, u_low, u_up;
  int i = get_global_id(0);
  x_low = initial_state_lower_bound(i);
  x_up = initial_state_upper_bound(i);
  u_low = input_lower_bound(i);
  u_up = input_upper_bound(i);
  /* for the radius dynamics, we want the initial state to be the radius of the interval 
   * (hence the name), that is one-half the distance between the upper and lower bound. */
  initial_state[i] = 0.5 * (x_up - x_low);
  final_state[i] = 0;
  k0[i] = 0;
  k1[i] = 0;
  k2[i] = 0;
  k3[i] = 0;
  tmp[i] = 0;
  input[i]=0.5 * (u_up - u_low);

}

#define RK4_NINT 5
#define RK4_H ((0.010000/RK4_NINT))

__kernel void gb_integrate_radius( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp)
{

  int i = get_global_id(0);
  float t = 0.000000;
  int nsteps = 100;
  float step_size = 0.010000;
  
  final_state[i] = initial_state[i];
  for (unsigned int k=0; k < 100; k++) {

    for (unsigned int w = 0; w < RK4_NINT; w++) {
   
      #undef dyn_fn 
      #define dyn_fn growth_bound_radius_dynamics
      #include "dynamics_body.cl"

    }
  }
}


