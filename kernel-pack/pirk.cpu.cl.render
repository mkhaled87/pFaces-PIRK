/*
* pirk.cpu.cl
*
*  date    : 04.07.2019
*  author  : A. Devonport | Electrical Engineering and Computer Sciences, Univeristy of California, Berkeley
*  about   : An OpenCL kernel for computing interval overapproximations of reachable sets.
* ***********************************************************************
*  The kernel manager will replace parameters enclosed by "@@" before compiling !
*/

#define CPU_VERSION

/* includes for the growth bound method */
// /home/hcs/Documents/pFaces/examples/pirk/ex_n_link/hi.cl

/* common utility file */

#include "/home/hcs/Documents/pFaces/examples/pirk/ex_n_link/dynamics.cl"
#include "/home/hcs/Documents/pFaces/examples/pirk/ex_n_link/bounds.cl"

#include "/home/hcs/Documents/pFaces/examples/pirk/ex_n_link/growth_bound_matrix.cl"
#include "/home/hcs/Documents/pFaces/examples/pirk/ex_n_link/jacobian_bounds.cl"

float growth_bound_radius_dynamics(float* r, float* u, float t, int i)
{
  float dr=0;
  for (int j=0; j < 1000; j++) {
    dr += growth_bound_matrix(i,j,u)*r[j];
  }
  dr += u[i]; //this is causing the bug
  return dr;
}


__kernel void gb_initialize_center( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
  float x_low, x_up, u_low, u_up;
  int i = get_global_id(0);
  x_low = initial_state_lower_bound(i);
  x_up = initial_state_upper_bound(i);
  u_low = input_lower_bound(i);
  u_up = input_upper_bound(i);
  /* for the center dynamics, we want the initial state to be the center of the interval 
   * (hence the name), that is the mean of the upper and lower bound. */
  initial_state[i] = 0.5 * (x_low + x_up);
  final_state[i] = initial_state[i];
  k0[i] = 0;
  k1[i] = 0;
  k2[i] = 0;
  k3[i] = 0;
  tmp[i] = 0;
  input[i]=0.5 * (u_up + u_low);
  *t = 0.000000;

}


#define step_size 0.100000
#define RK4_NINT 5
#define RK4_H ((0.100000/RK4_NINT))

#define gb_integrate_dynchoice_1 gb_integrate_center_1
#define gb_integrate_dynchoice_2 gb_integrate_center_2
#define gb_integrate_dynchoice_3 gb_integrate_center_3
#define gb_integrate_dynchoice_4 gb_integrate_center_4
#define gb_integrate_dynchoice_5 gb_integrate_center_5
#define gb_integrate_dynchoice_6 gb_integrate_center_6
#define gb_integrate_dynchoice_7 gb_integrate_center_7
#define gb_integrate_dynchoice_8 gb_integrate_center_8

#define dynfn dynamics_element

__kernel void gb_integrate_dynchoice_1( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];
    for(int k=0; k<1000;k++) {
        xlocal[k] = final_state[k];
        ulocal[k] = input[k];
    }
    k0[i] = dynfn(xlocal, ulocal, *t, i);
    tmp[i] = final_state[i] + RK4_H / 2.0*k0[i];
}

__kernel void gb_integrate_dynchoice_2( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];

    for(int k=0; k<1000;k++) {
        xlocal[k] = tmp[k];
        ulocal[k] = input[k];
    }
    k1[i] = dynfn(xlocal, ulocal, *t + 0.5*step_size,  i);
    tmp[i] = final_state[i] + RK4_H / 2.0*k1[i];
}

__kernel void gb_integrate_dynchoice_3( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];
    for(int k=0; k<1000;k++) {
        xlocal[k] = tmp[k];
        ulocal[k] = input[k];
    }
    k2[i] = dynfn(xlocal, ulocal, *t + 0.5*step_size, i);
    tmp[i] = final_state[i] + RK4_H * k2[i];
}

__kernel void gb_integrate_dynchoice_4( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];
    for(int k=0; k<1000;k++) {
        xlocal[k] = tmp[k];
        ulocal[k] = input[k];
    }
    k3[i] = dynfn(xlocal, ulocal, *t +  step_size, i);
    final_state[i] = final_state[i] + (RK4_H / 6.0)*(k0[i] + 2.0*k1[i] + 2.0*k2[i] + k3[i]);
    *t += RK4_H;
}



__kernel void gb_initialize_radius( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
  float x_low, x_up, u_low, u_up;
  int i = get_global_id(0);
  x_low = initial_state_lower_bound(i);
  x_up = initial_state_upper_bound(i);
  u_low = input_lower_bound(i);
  u_up = input_upper_bound(i);
  /* for the radius dynamics, we want the initial state to be the radius of the interval 
   * (hence the name), that is one-half the distance between the upper and lower bound. */
  initial_state[i] = 0.5 * (x_up - x_low);
  final_state[i] = initial_state[i];
  k0[i] = 0;
  k1[i] = 0;
  k2[i] = 0;
  k3[i] = 0;
  tmp[i] = 0;
  input[i]=0.5 * (u_up - u_low);
  *t = 0.000000;

}

#undef gb_integrate_dynchoice_1
#undef gb_integrate_dynchoice_2
#undef gb_integrate_dynchoice_3
#undef gb_integrate_dynchoice_4
#undef gb_integrate_dynchoice_5
#undef gb_integrate_dynchoice_6
#undef gb_integrate_dynchoice_7
#undef gb_integrate_dynchoice_8

#undef dynfn

#define gb_integrate_dynchoice_1 gb_integrate_radius_1
#define gb_integrate_dynchoice_2 gb_integrate_radius_2
#define gb_integrate_dynchoice_3 gb_integrate_radius_3
#define gb_integrate_dynchoice_4 gb_integrate_radius_4
#define gb_integrate_dynchoice_5 gb_integrate_radius_5
#define gb_integrate_dynchoice_6 gb_integrate_radius_6
#define gb_integrate_dynchoice_7 gb_integrate_radius_7
#define gb_integrate_dynchoice_8 gb_integrate_radius_8
#define dynfn growth_bound_radius_dynamics

__kernel void gb_integrate_dynchoice_1( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];
    for(int k=0; k<1000;k++) {
        xlocal[k] = final_state[k];
        ulocal[k] = input[k];
    }
    k0[i] = dynfn(xlocal, ulocal, *t, i);
    tmp[i] = final_state[i] + RK4_H / 2.0*k0[i];
}

__kernel void gb_integrate_dynchoice_2( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];

    for(int k=0; k<1000;k++) {
        xlocal[k] = tmp[k];
        ulocal[k] = input[k];
    }
    k1[i] = dynfn(xlocal, ulocal, *t + 0.5*step_size,  i);
    tmp[i] = final_state[i] + RK4_H / 2.0*k1[i];
}

__kernel void gb_integrate_dynchoice_3( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];
    for(int k=0; k<1000;k++) {
        xlocal[k] = tmp[k];
        ulocal[k] = input[k];
    }
    k2[i] = dynfn(xlocal, ulocal, *t + 0.5*step_size, i);
    tmp[i] = final_state[i] + RK4_H * k2[i];
}

__kernel void gb_integrate_dynchoice_4( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    float xlocal[1000];
    float ulocal[1000];
    for(int k=0; k<1000;k++) {
        xlocal[k] = tmp[k];
        ulocal[k] = input[k];
    }
    k3[i] = dynfn(xlocal, ulocal, *t +  step_size, i);
    final_state[i] = final_state[i] + (RK4_H / 6.0)*(k0[i] + 2.0*k1[i] + 2.0*k2[i] + k3[i]);
    *t += RK4_H;
}



float ctmm_decomposition_dynamics(
  __global float *x,
  __global float *u,
  float t,
  int i
)
{
    /* First, we need to figure out if we're computing the 'top half' or the 'bottom half' of the dynamics. The only difference will be
    which 'half' of the vectors we treat as the 'star' part and which we treat as the 'non-star' part.*/
    int idx;
    int idx_hat;

    int idx_nom;
    int offset;
    int hat_offset;
    if(i - 1000 <= 0) {
        /* The index is in the 'upper half', so we're computing g(x,u,xhat,uhat). */
        idx = i;
        offset = 0;
        idx_hat = i + 1000;
        hat_offset = 1000;
        idx_nom = i;

    }
    else {
        /* the index is in the 'lower half', so we're computing g(xhat,uhat,x,u). */
        idx = i;
        offset = 1000;
        idx_hat = i - 1000;
        hat_offset = 0;
        idx_nom = i - 1000;
    }
    float xi[1000];
    float pi[1000];
    float alpha[1000];
    float beta[1000];
    float dh;
    
    for(int k=0; k < 1000; k++) {
        float ju = state_jacobian_upper_bound(i,k);
        float jl = state_jacobian_lower_bound(i,k);
        float jm = 0.5 * (ju + jl);
        if(jm >= 0) {
            xi[k] = x[idx];
            alpha[k] = fmax((float) 0.0, -jl);
        }
        else {
            xi[k] = x[idx_hat];
            alpha[k] = fmax((float) 0.0, ju);
        }
    }
    alpha[idx_nom] = 0.0;
    xi[idx_nom] = x[idx];

    for(int k=0; k < 10; k++) {
        float ju = input_jacobian_upper_bound(i,k);
        float jl = input_jacobian_lower_bound(i,k);
        float jm = 0.5 * (ju + jl);
        if(jm >= 0) {
            pi[k] = u[idx];
            beta[k] = fmax((float) 0.0, -jl);
        }
        else {
            pi[k] = u[idx_hat];
            beta[k] = fmax((float) 0.0, ju);
        }
    }
    
    dh = dynamics_element_local(xi, pi, t, i);
    for(int k=0; k < 1000; k++) {
        dh += alpha[k] * (x[k+offset] - x[k+hat_offset]);
    }
    for(int k=0; k < 10; k++) {
        dh += beta[k] * (u[k+offset] - u[k+hat_offset]);
    }
    return dh;
    
    

}
__kernel void ctmm_initialize( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
  float x_low, x_up, u_low, u_up;
  int i = get_global_id(0);
    if(i - 1000 <= 0) {
        /* The index is in the 'upper half', so we're computing g(x,u,xhat,uhat). */
        initial_state[i] = initial_state_lower_bound(i);
        final_state[i] = initial_state[i];
        input[i] = input_lower_bound(i);

    }
    else {
        /* the index is in the 'lower half', so we're computing g(xhat,uhat,x,u). */
        initial_state[i] = initial_state_upper_bound(i-1000);
        final_state[i] = initial_state[i];
        input[i] = input_upper_bound(i-1000);
    }
  k0[i] = 0;
  k1[i] = 0;
  k2[i] = 0;
  k3[i] = 0;
  tmp[i] = 0;
  *t = 0.000000;

}
__kernel void ctmm_integrate_1( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    k0[i] = ctmm_decomposition_dynamics(final_state, input, *t, i);
    tmp[i] = final_state[i] + RK4_H / 2.0*k0[i];
}

__kernel void ctmm_integrate_2( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    k1[i] = ctmm_decomposition_dynamics(tmp, input, *t + 0.5*step_size,  i);
    tmp[i] = final_state[i] + RK4_H / 2.0*k1[i];
}

__kernel void ctmm_integrate_3( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    k2[i] = ctmm_decomposition_dynamics(tmp, input, *t + 0.5*step_size, i);
    tmp[i] = final_state[i] + RK4_H * k2[i];
}

__kernel void ctmm_integrate_4( 
    __global float *initial_state,
    __global float *final_state, 
    __global float *input,
    __global float *k0,
    __global float *k1,
    __global float *k2,
    __global float *k3,
    __global float *tmp,
    __global float *t)
{
    int i = get_global_id(0);  
    k3[i] = ctmm_decomposition_dynamics(tmp, input, *t +  step_size, i);
    final_state[i] = final_state[i] + (RK4_H / 6.0)*(k0[i] + 2.0*k1[i] + 2.0*k2[i] + k3[i]);
    *t += RK4_H;
}
